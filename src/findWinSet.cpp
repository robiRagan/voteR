// [[Rcpp::interfaces(r, cpp)]]
// [[Rcpp::plugins("cpp11")]]
#include <Rcpp.h>
#include <vector>
#include "../inst/include/voteR.h"
using namespace Rcpp;
//' findWinSet
//' 
//' Takes a set of indifference curves and returns the k-najority Rule WinSet. The IC's should be stored as a list
//' of DataFrames where each data framd in the list is the point set that constitutes the boundries of each voter's Indifference Curve. 
//' These ICs are usually generated by \code{\link{findICPoints}}
//' 
//' Possible TODO: 1) Could add a simplify at the begining from <boost/geometry/algorithms/simplify.hpp> to possibaly decrease the number of points in each IC.
//'                 2) Also could switch entire package to use Well Know Text as is used in the {sf} package. Then all polygons could be 
//'                 supplied as a single elements in a list (rather than as data frames in a list.)
//' 
//' @param indifferenceCurves A numberOffVoters list of data frames from R. Each data frame is the point set for a voters 
//'   
//' @param kToDefeatSQ A scalar indicating the number of indifference curves that must overlap to create the Win Set 
//'     (aka the k-majority rule).
//'  
//' @return winSetList A list of data frames where each data frame is a point set that defines one of the disjoint sets that are the 
//'     boundries of the win set. If there are less than two disjoint sets then the list will contain only one data frame. 
//' 
//' @export
//'
// [[Rcpp::export]]
List findWinSet(List indifferenceCurves){
       Rcpp::List inputList(indifferenceCurves) ;
        
        // Pull an IC from the supplied list.
        NumericMatrix IC1Named = indifferenceCurves[0];
        // Store the voter name.
        double IC1Name = IC1Named( 0 , 0 );
        // Store the point set of the IC as a NumericMatrix
        NumericMatrix IC1NoName = IC1Named( _ , Range(1,2) );
        //Convert the NumericMatric PoinSet to a Boost Polygon
         boostPolygon aBoostPolygon1 = as<boostPolygon>(IC1NoName);

       
       
       
       
       
       
       // Pull an IC from the supplied list.
       NumericMatrix IC2Named = indifferenceCurves[1];
       // Store the voter name.
       double IC2Name = IC2Named( 0 , 0 );
       // Store the point set of the IC as a NumericMatrix
       NumericMatrix IC2NoName = IC2Named( _ , Range(1,2) );
       //Convert the NumericMatric PoinSet to a Boost Polygon
       boostPolygon aBoostPolygon2 = as<boostPolygon>(IC2NoName);
       
       
       

       // Pull an IC from the supplied list.
       NumericMatrix IC3Named = indifferenceCurves[2];
       // Store the voter name.
       double IC3Name = IC3Named( 0 , 0 );
       // Store the point set of the IC as a NumericMatrix
       NumericMatrix IC3NoName = IC3Named( _ , Range(1,2) );
       //Convert the NumericMatric PoinSet to a Boost Polygon
       boostPolygon aBoostPolygon3 = as<boostPolygon>(IC3NoName);




       // Pull an IC from the supplied list.
       NumericMatrix IC4Named = indifferenceCurves[3];
       // Store the voter name.
       double IC4Name = IC4Named( 0 , 0 );
       // Store the point set of the IC as a NumericMatrix
       NumericMatrix IC4NoName = IC4Named( _ , Range(1,2) );
       //Convert the NumericMatric PoinSet to a Boost Polygon
       boostPolygon aBoostPolygon4 = as<boostPolygon>(IC4NoName);






       // Pull an IC from the supplied list.
       NumericMatrix IC5Named = indifferenceCurves[4];
       // Store the voter name.
       double IC5Name = IC5Named( 0 , 0 );
       // Store the point set of the IC as a NumericMatrix
       NumericMatrix IC5NoName = IC5Named( _ , Range(1,2) );
       //Convert the NumericMatric PoinSet to a Boost Polygon
       boostPolygon aBoostPolygon5 = as<boostPolygon>(IC5NoName);


       
       
       return(Rcpp::List::create(aBoostPolygon1, aBoostPolygon2, aBoostPolygon3, aBoostPolygon4, aBoostPolygon5) ) ;
    
    // return xlist;
    
   // return List::create(n);
    
    // NumericVector convertedSalience = pow(salienceVector, -1); 
    // 
    // 
    // // Find the Radius of the SuperElipse.
    // 
    // double theSuperElipseRadius = voteR::superElipseRadius(idealPoint, altPointVector, orderScalar, salienceVector);
    // 
    // 
    // std::vector<double> xCoords;
    // std::vector<double> yCoords;
    // 
    // double expN = 2.0 / orderScalar;
    // double expM = 2.0 / orderScalar;
    // // precision *= PI + 1 does this: precision = precision * (PI + 1);
    // precision *= PI;
    // 
    // for (double theta = -PI; theta < PI; theta += precision) {
    //     double cosTheta = cos ( theta );
    //     double sinTheta = sin ( theta );
    //     double absCosTheta = fabs ( cosTheta );
    //     double absSinTheta = fabs ( sinTheta );
    //     double powAbsCosTheta = pow ( absCosTheta, expM );
    //     double powAbsSinTheta = pow ( absSinTheta, expN );
    //     double x = theSuperElipseRadius * convertedSalience(0) * powAbsCosTheta * voteR::sgn ( cos ( theta ) );
    //     double y = theSuperElipseRadius * convertedSalience(1) * powAbsSinTheta * voteR::sgn ( sin ( theta ) );
    //     xCoords.emplace_back ( x + idealPoint(0) );
    //     yCoords.emplace_back ( y + idealPoint(1) );
    // }
    // 
    // // Convert std::vector<double> to Rcpp::NumericVector
    // NumericVector xCoordsRcpp = wrap(xCoords);
    // NumericVector yCoordsRcpp = wrap(yCoords);
    // 
    // // Create the output matrix
    // // NumericMatrix ICout(xCoords.size(), 3);
    // 
    // // Create voter ID as a vector to be used for grouping purposes when plotting
    // 
    // NumericVector voterIDVector = rep( voterID, xCoords.size() );
    // 
    // // Store the output in a list before sending it back to R
    // return DataFrame::create(_["voterID"]= voterIDVector, _["xCoords"]= xCoordsRcpp, _["yCoords"]= yCoordsRcpp);
    

    
}
